#!/usr/bin/env bash

# Local check that we are likely to pass CI
# CI is quite slow so it's nice to be able to run locally

set -o errexit
set -o xtrace

# ensure rustfmt has been run
cargo fmt --all -- --check
# ensure we don't have broken links in docs
cargo doc --all-features --document-private-items

# ensure we at least compile without default features
cargo check --manifest-path=fontir/Cargo.toml --no-default-features
cargo check --manifest-path=ufo2fontir/Cargo.toml --no-default-features
cargo check --manifest-path=fontc/Cargo.toml --no-default-features

cargo clippy --all-features --all-targets -- -D warnings

cargo test --all-features
cargo test --no-default-features


grep_rust_lines_with_prints() {
    for file in $(git ls-files '*.rs'); do
        # Strip all inline comments
        sed -e 's://.*$::' "$file" | \
        # Prepend the file name and line number to each line, with colors
        awk -v file="$file" '{ printf "\033[35m%s\033[0m:\033[32m%s\033[0m: %s\n", file, FNR, $0 }' | \
        # Grep for print statements
        grep --color=always -E '\b(println!|eprintln!)' || true
    done
}


diff_rust_lines_with_prints() {
    local from_ref="$1"
    local to_ref="${2:-HEAD}"
    # --diff-filter=A is to list only added files, excluding modified/deleted
    git diff "$from_ref" "$to_ref" --name-only --diff-filter=A | \
    grep '\.rs$' | \
    while read -r file; do
        # For each file, get a unified diff with no context (-U0)
        git diff "$from_ref" "$to_ref" -U0 -- "$file" | \
        # Strip lines starting with '+++' containing the file name
        grep -v -E '^\+\+\+' | \
        # Select only the added lines, i.e. starting with a plus sign
        grep -E '^\+' | \
        # Strip the '+' prefix and the inline comments
        sed -e 's/^\+//' -e 's://.*$::' | \
        # Prepend the file name and line number to each line, with colors
        awk -v file="$file" '{ printf "\033[35m%s\033[0m:\033[32m%s\033[0m: %s\n", file, FNR, $0 }' | \
        # Grep for print statements
        grep --color=always -E '\b(println!|eprintln!)' || true
    done
}

# xtrace gets in the way here, disable it and don't even print 'set -x' :)
{ set +x; } 2>/dev/null

# Check for println! or eprintln! in Rust files about to be pushed, ignoring comments.
# The pre-push git hook receives info about what is to be pushed from stdin, see:
# https://git-scm.com/docs/githooks#_pre_push
# The `test` Unix command -t NUM option returns true if the given file descriptor (0 for stdin)
# is open and associated with a terminal, and false if the input is piped.
# When this is run as a regular script (input is a terminal), all the git-tracked *.rs files
# are searched. When it's run as a hook (input is a pipe) only the added lines from the diff
# between local and remote refs are searched.
if [ -t 0 ]; then
    matches=$(grep_rust_lines_with_prints)
else
    while read -r _local_ref local_sha _remote_ref remote_sha; do
        matches=$(diff_rust_lines_with_prints "$remote_sha" "$local_sha")
    done
fi
if [ ! -z "$matches" ]; then
    echo "Error: The following Rust source files contain println! or eprintln! statements:"
    echo "$matches"
    echo "Please remove or comment out the println! and eprintln! statements before pushing."
    exit 1
fi
exit 0
